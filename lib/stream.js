// Generated by CoffeeScript 1.6.3
var Stream,
  __slice = [].slice;

Stream = (function() {
  var AC, FD, NT, fs, mime, path, util, zlib;

  fs = require('fs');

  util = require('util');

  path = require('path');

  zlib = require('zlib');

  mime = require('mime');

  NT = require('negotiator');

  AC = require('async-cache');

  FD = require('fd');

  Stream.prototype.path = false;

  Stream.prototype.url = false;

  Stream.prototype.opt = {};

  Stream.prototype.none = {
    max: 1,
    maxSize: 0,
    length: function() {
      return Infinity;
    }
  };

  Stream.prototype.noneCacheOptions = {
    fd: Stream.none,
    stat: Stream.none,
    index: Stream.none,
    readdir: Stream.none,
    content: Stream.none
  };

  Stream.prototype.cacheOptions = {
    fd: {
      max: 1000,
      maxAge: 1000 * 60 * 60
    },
    stat: {
      max: 5000,
      maxAge: 1000 * 60
    },
    content: {
      max: 1024 * 1024 * 64,
      maxAge: 1000 * 60 * 10,
      length: function(n) {
        return n.length;
      }
    },
    index: {
      max: 1024 * 8,
      maxAge: 1000 * 60 * 10,
      length: function(n) {
        return n.length;
      }
    },
    readdir: {
      max: 1000,
      maxAge: 1000 * 60 * 10,
      length: function(n) {
        return n.length;
      }
    }
  };

  Stream.prototype.setCahceOptions = function() {
    var opt, set;
    opt = this.opt.cache;
    set = function(key) {
      if (opt[key] === false) {
        return this.none;
      }
      return util._extend(util._extend({}, this.cacheOptions[key]), opt[key]);
    };
    if (opt === false) {
      return opt = this.none;
    }
  };

  function Stream(opt) {
    if (typeof opt === 'string') {
      this.path = opt;
      opt = arguments[1];
      if (typeof opt === 'string') {
        this.url = opt;
        opt = arguments[2];
      }
    }
    opt = util._extend({}, opt || {});
    if (!this.path) {
      this.path = opt.path;
    }
    if (typeof p !== 'string') {
      throw new Error('no path specified');
    }
    this.path = path.resolve(this.path);
    if (!this.url) {
      this.url = opt.url;
    }
    if (!this.url) {
      this.url = '';
    }
    if ('/' !== this.url.charAt(0)) {
      this.url = "/" + this.url;
    }
    opt.url = this.url;
    opt.path = this.path;
    this.opt = opt;
  }

  Stream.prototype.cachecheck = function(req, res, stats) {
    var etags, match, mtime, range, since;
    mtime = stats.mtime.toUTCString();
    since = (new Date(req.headers['if-modified-since'])).toUTCString();
    res.setHeader('Last-Modified', mtime);
    if (since >= mtime) {
      return true;
    }
    etags = "\"" + stats.dev + "-" + stats.ino + "-" + mtime + "\"";
    match = req.headers['if-none-match'];
    res.setHeader('ETag', etags);
    if (etags === match) {
      return true;
    }
    range = req.headers['If-Range'];
    if (mtime === (new Date(range)).toUTCString()) {
      return true;
    }
    if (etags === range) {
      return true;
    }
    return false;
  };

  Stream.prototype.rangeParser = function(req, res, stats) {
    var end, ini, size, _ref, _ref1;
    size = stats.size;
    if (((_ref = req.headers) != null ? _ref.range : void 0) != null) {
      res.statusCode = 206;
      _ref1 = req.headers.range.replace('bytes=', '').split('-').map(function(n) {
        return parseInt(n, 10);
      }), ini = _ref1[0], end = _ref1[1];
      if ((isNaN(end)) || (end === 0)) {
        end = size - 1;
      }
      res.setHeader('Content-Length', end + 1 - ini);
      res.setHeader('Content-Range', "bytes " + ini + "-" + end + "/" + size);
      res.setHeader('Accept-Range', 'bytes');
      res.setHeader('Transfer-Encoding', 'chunked');
      return [ini, end];
    } else {
      res.statusCode = 200;
      res.setHeader('Content-Length', size);
      return [0, size - 1];
    }
  };

  Stream.prototype["interface"] = function() {
    var callback, options, opts, req, res, src,
      _this = this;
    req = arguments[0], res = arguments[1], src = arguments[2], opts = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    options = {};
    callback = function() {};
    while (opts.shift()) {
      if (typeof opt === 'object') {
        options = opt;
      }
      if (typeof opt === 'function') {
        callback = opt;
      }
    }
    options.headers || (options.headers = {});
    src = path.resolve(src);
    return fs.stat(src, function(err, stats) {
      var end, key, start, stream, value, _base, _base1, _ref, _ref1;
      if (err) {
        callback(err, 0, 0);
        res.statusCode = 500;
        return next(err);
      }
      if (_this.cachecheck(req, res, stats)) {
        callback(null, 0, 1);
        res.statusCode = 304;
        return res.end();
      }
      (_base = options.headers)['Cache-Control'] || (_base['Cache-Control'] = 'public');
      (_base1 = options.headers)['Content-Type'] || (_base1['Content-Type'] = mime.lookup(src));
      _ref = options.headers;
      for (key in _ref) {
        value = _ref[key];
        res.setHeader(key, value);
      }
      _ref1 = _this.rangeParser(req, res, stats), start = _ref1[0], end = _ref1[1];
      if (start > end || stats.size < start) {
        res.statusCode = 416;
        start = 0;
        end = stats.size - 1;
        res.setHeader('Content-Length', end + 1 - start);
        res.setHeader('Content-Range', "" + start + "-" + end + "/" + stats.size);
      }
      stream = fs.createReadStream(src, {
        start: start,
        end: end
      });
      stream.on('close', function() {
        return callback(null, start, end);
      });
      stream.on('error', function(err) {
        console.error('>', err);
        return callback(err, start, end);
      });
      return stream.pipe(res);
    });
  };

  return Stream;

})();

module.exports = function() {
  var opts;
  opts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return function(req, res, next) {
    var stream;
    stream = new Stream(opts);
    res.stream = function() {
      var opts, src;
      src = arguments[0], opts = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return stream["interface"](req, res, src, opts);
    };
    return next();
  };
};
