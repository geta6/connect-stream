// Generated by CoffeeScript 1.6.2
var AC, FD, defaultCacheOptions, fs, mime, path, _;

fs = require('fs');

path = require('path');

_ = require('underscore');

AC = require('async-cache');

FD = (require('fd'))();

mime = require('mime');

defaultCacheOptions = {
  path: path.resolve('public'),
  "static": true,
  fd: {
    max: 1000,
    maxAge: 1000 * 60 * 60
  },
  stat: {
    max: 5000,
    maxAge: 1000 * 60
  }
};

module.exports = function(cacheOptions) {
  var cache;

  if (cacheOptions == null) {
    cacheOptions = {};
  }
  cacheOptions = _.defaults(cacheOptions, defaultCacheOptions);
  if ('/' !== cacheOptions.path.substr(0, 1)) {
    cacheOptions.path = path.resolve(cacheOptions.path);
  }
  cache = {
    fd: AC(_.extend(cacheOptions.fd, {
      load: FD.open.bind(FD),
      dispose: FD.close.bind(FD)
    })),
    stat: AC(_.extend(cacheOptions.stat, {
      load: function(addr, done) {
        return fs.stat(addr, done);
      }
    }))
  };
  return function(req, res, next) {
    var defaultFailureFunction, defaultSuccessFunction, src, stream;

    defaultSuccessFunction = function() {};
    defaultFailureFunction = function() {
      res.writeHead(404, {
        'Content-Type': 'text/plain'
      });
      return res.end("Cannot " + (req.method.toUpperCase()) + " " + req.url);
    };
    stream = res.stream = function(src, streamOptions) {
      if (streamOptions == null) {
        streamOptions = {};
      }
      streamOptions.success || (streamOptions.success = defaultSuccessFunction);
      streamOptions.failure || (streamOptions.failure = defaultFailureFunction);
      streamOptions.headers || (streamOptions.headers = {});
      if ('/' !== src.substr(0, 1)) {
        src = path.join(cacheOptions.path, src);
      }
      return cache.stat.get(src, function(err, stat) {
        var modified, _base, _base1, _base2, _base3;

        if (err || !stat.isFile()) {
          return streamOptions.failure(err, stat, [0, 1]);
        }
        modified = stat.mtime.toUTCString();
        if ((String(req.headers['if-modified-since'])) === modified) {
          res.statusCode = 304;
          streamOptions.success(null, stat, [0, 1]);
          return res.end();
        }
        (_base = streamOptions.headers)['Cache-Control'] || (_base['Cache-Control'] = "public");
        (_base1 = streamOptions.headers)['Content-Type'] || (_base1['Content-Type'] = mime.lookup(src));
        (_base2 = streamOptions.headers)['Last-Modified'] || (_base2['Last-Modified'] = modified);
        (_base3 = streamOptions.headers)['ETag'] || (_base3['ETag'] = "\"" + stat.dev + "-" + stat.ino + "-" + (stat.mtime.getTime()) + "\"");
        return cache.fd.get(src, function(err, fd) {
          var checkIn, end, ini, n, readStream, total, _base4, _ref, _ref1;

          checkIn = FD.checkinfn(src, fd);
          FD.checkout(src, fd);
          if (!req.headers.range) {
            _ref = [0, stat.size], ini = _ref[0], end = _ref[1];
            streamOptions.headers['Content-Length'] = stat.size;
            res.writeHead(200, streamOptions.headers);
          } else {
            total = stat.size;
            _ref1 = (function() {
              var _i, _len, _ref1, _results;

              _ref1 = (req.headers.range.replace('bytes=', '')).split('-');
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                n = _ref1[_i];
                _results.push(parseInt(n, 10));
              }
              return _results;
            })(), ini = _ref1[0], end = _ref1[1];
            if ((isNaN(end)) || (end === 0)) {
              end = total - 1;
            }
            streamOptions.headers['Content-Length'] = end + 1 - ini;
            streamOptions.headers['Content-Range'] = "bytes " + ini + "-" + end + "/" + total;
            streamOptions.headers['Accept-Range'] = 'bytes';
            (_base4 = streamOptions.headers)['Transfer-Encoding'] || (_base4['Transfer-Encoding'] = 'chunked');
            res.writeHead(206, streamOptions.headers);
          }
          console.log(streamOptions.headers);
          readStream = fs.createReadStream(src, {
            fd: fd,
            start: ini,
            end: end
          });
          readStream.destroy = function() {};
          readStream.on('end', function() {
            streamOptions.success(null, stat, [ini, end]);
            return checkIn.apply(this, arguments);
          });
          readStream.on('error', function(err) {
            streamOptions.failure(err, stat, [ini, end]);
            return checkIn.apply(this, arguments);
          });
          return readStream.pipe(res);
        });
      });
    };
    if (cacheOptions["static"] && req.url !== '/') {
      if (fs.existsSync((src = path.join(cacheOptions.path, req.url)))) {
        return stream(src, {});
      }
    }
    return next();
  };
};
