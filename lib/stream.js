// Generated by CoffeeScript 1.6.3
module.exports = function(req, res, next) {
  var fs, mime, options, path, stream;
  fs = require('fs');
  path = require('path');
  mime = require('mime');
  options = {
    headers: {},
    complete: function() {}
  };
  stream = function(src, opt) {
    var e, end, etags, fstat, ini, key, match, mtime, n, readstream, since, total, value, _base, _base1, _base2, _base3, _base4, _base5, _ref, _ref1, _ref2;
    if (typeof opt === 'function') {
      options.complete = opt;
    }
    if (typeof opt === 'object') {
      if (opt.headers != null) {
        options.headers = opt.headers;
      }
      if (opt.complete != null) {
        options.complete = opt.complete;
      }
    }
    req.route || (req.route = {});
    (_base = req.route).path || (_base.path = 'Stream');
    try {
      if ('/' !== src.substr(0, 1)) {
        src = path.join(options.path, src);
      }
      if (!fs.existsSync(src)) {
        throw new Error('ENOEXISTS');
      }
      fstat = fs.statSync(src);
      if (!fstat.isFile()) {
        throw new Error('ENOTFILE');
      }
      mtime = fstat.mtime.getTime();
      since = (new Date(req.headers['if-modified-since'])).getTime();
      if (since >= mtime) {
        options.complete(null, [0, 1], src);
        res.statusCode = 304;
        return res.end();
      }
      etags = "\"" + fstat.dev + "-" + fstat.ino + "-" + mtime + "\"";
      match = req.headers['if-none-match'];
      if (etags === match) {
        options.complete(null, [0, 1], src);
        res.statusCode = 304;
        return res.end();
      }
      (_base1 = options.headers)['Cache-Control'] || (_base1['Cache-Control'] = 'public');
      (_base2 = options.headers)['Content-Type'] || (_base2['Content-Type'] = mime.lookup(src));
      (_base3 = options.headers)['Last-Modified'] || (_base3['Last-Modified'] = fstat.mtime.toUTCString());
      (_base4 = options.headers)['ETag'] || (_base4['ETag'] = etags);
      if (!req.headers.range) {
        res.statusCode = 200;
        _ref = [0, fstat.size], ini = _ref[0], end = _ref[1];
        options.headers['Content-Length'] = fstat.size;
      } else {
        res.statusCode = 206;
        total = fstat.size;
        _ref1 = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = (req.headers.range.replace('bytes=', '')).split('-');
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            n = _ref1[_i];
            _results.push(parseInt(n, 10));
          }
          return _results;
        })(), ini = _ref1[0], end = _ref1[1];
        if ((isNaN(end)) || (end === 0)) {
          end = total - 1;
        }
        options.headers['Content-Length'] = end + 1 - ini;
        options.headers['Content-Range'] = "bytes " + ini + "-" + end + "/" + total;
        options.headers['Accept-Range'] = 'bytes';
        (_base5 = options.headers)['Transfer-Encoding'] || (_base5['Transfer-Encoding'] = 'chunked');
      }
      _ref2 = options.headers;
      for (key in _ref2) {
        value = _ref2[key];
        res.setHeader(key, value);
      }
      readstream = fs.createReadStream(src, {
        start: ini,
        end: end
      });
      readstream.on('end', function() {
        return options.complete(null, [ini, end], src);
      });
      readstream.on('error', function(err) {
        throw "ERRSTREAM " + src + " " + ini + "-" + end + " " + (err.stack || err.message);
      });
      return readstream.pipe(res);
    } catch (_error) {
      e = _error;
      options.complete(e, [0, 0], src);
      res.statusCode = 500;
      return next(new Error("" + e + ": " + src + " (" + req.url + ")"));
    }
  };
  res.stream = stream;
  return next();
};
