// Generated by CoffeeScript 1.6.3
var fs, mime, path, st,
  __slice = [].slice;

fs = require('fs');

st = require('st');

path = require('path');

mime = require('mime');

module.exports = function(options) {
  var mount;
  if (options == null) {
    options = {};
  }
  options["static"] || (options["static"] = true);
  options.url || (options.url = '/');
  options.path || (options.path = path.resolve('public'));
  options.index || (options.index = false);
  options.passthrough || (options.passthrough = true);
  mount = st(options);
  return function(req, res, next) {
    var defaults;
    defaults = {
      complete: function(err, ini, end) {}
    };
    res.stream = function() {
      var arg, args, src, streams, _i, _len;
      src = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!src) {
        throw new Error('NOSOURCE');
      }
      if (req.method.toUpperCase() === 'HEAD') {
        res.end();
      }
      streams = {};
      streams.complete || (streams.complete = defaults.complete);
      streams.headers || (streams.headers = {});
      streams.debug || (streams.debug = false);
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        if (typeof arg === 'function') {
          streams.complete = arg;
        } else if (typeof arg === 'object') {
          if (arg.headers) {
            streams.headers = arg.headers;
          }
          if (arg.debug) {
            sterams.debug = arg.debug;
          }
          if (arg.complete && typeof arg.complete === 'function') {
            sterams.complete = arg.complete;
          }
        }
      }
      if ('/' !== src.substr(0, 1)) {
        src = path.join(options.path, src);
      }
      return mount._this.cache.fd.get(src, function(err, fd) {
        var failure, fdend, success;
        if (err) {
          streams.complete(err, 0, 0);
          res.writeHead(404, {
            'Content-Type': 'text/plain'
          });
          return res.end("Cannot Stream " + req.url);
        }
        mount._this.fdman.checkout(src, fd);
        fdend = mount._this.fdman.checkinfn(src, fd);
        success = function(ini, end) {
          streams.complete(null, ini, end);
          return fdend();
        };
        failure = function(err) {
          streams.complete(err, 0, 0);
          res.writeHead(404, {
            'Content-Type': 'text/plain'
          });
          res.end("Cannot Stream " + req.url);
          return fdend();
        };
        return mount._this.cache.stat.get("" + fd + ":" + src, function(err, stat) {
          var end, etag, ims, ini, mtime, n, readStream, total, _base, _base1, _base2, _base3, _base4, _ref, _ref1;
          if (err) {
            return failure(err);
          }
          if (stat.isDirectory()) {
            return failure(new Error('ISDIR'));
          }
          mtime = stat.mtime.getTime();
          if ((ims = req.headers['if-modified-since'])) {
            ims = new Date(ims).getTime();
            if (ims >= mtime) {
              res.statusCode = 304;
              res.end();
              return success(0, 1);
            }
          }
          etag = "\"" + stat.dev + "-" + stat.ino + "-" + mtime + "\"";
          if (etag === req.headers['if-none-match']) {
            res.statusCode = 304;
            res.end();
            return success(0, 1);
          }
          (_base = streams.headers)['Cache-Control'] || (_base['Cache-Control'] = 'public');
          (_base1 = streams.headers)['Content-Type'] || (_base1['Content-Type'] = mime.lookup(src));
          (_base2 = streams.headers)['Last-Modified'] || (_base2['Last-Modified'] = stat.mtime.toUTCString());
          (_base3 = streams.headers)['ETag'] || (_base3['ETag'] = etag);
          if (!req.headers.range) {
            _ref = [0, stat.size], ini = _ref[0], end = _ref[1];
            streams.headers['Content-Length'] = stat.size;
            res.writeHead(200, streams.headers);
          } else {
            total = stat.size;
            _ref1 = (function() {
              var _j, _len1, _ref1, _results;
              _ref1 = (req.headers.range.replace('bytes=', '')).split('-');
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                n = _ref1[_j];
                _results.push(parseInt(n, 10));
              }
              return _results;
            })(), ini = _ref1[0], end = _ref1[1];
            if ((isNaN(end)) || (end === 0)) {
              end = total - 1;
            }
            streams.headers['Content-Length'] = end + 1 - ini;
            streams.headers['Content-Range'] = "bytes " + ini + "-" + end + "/" + total;
            streams.headers['Accept-Range'] = 'bytes';
            (_base4 = streams.headers)['Transfer-Encoding'] || (_base4['Transfer-Encoding'] = 'chunked');
            res.writeHead(206, streams.headers);
          }
          readStream = fs.createReadStream(src, {
            fd: fd,
            start: ini,
            end: end
          });
          readStream.destroy = function() {};
          readStream.on('end', function() {
            return process.nextTick(function() {
              if (streams.debug) {
                console.warn('Streaming %s fd=%d\n', src, fd, process.memoryUsage());
              }
              return success(ini, end);
            });
          });
          readStream.on('error', function(err) {
            console.error('Error serving %s fd=%d\n%s', src, fd, err.stack || err.message);
            return failure(err);
          });
          return readStream.pipe(res);
        });
      });
    };
    if (options["static"]) {
      if (mount(req, res, next)) {
        return;
      }
    }
    return next();
  };
};
