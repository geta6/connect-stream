// Generated by CoffeeScript 1.6.3
var Stream,
  __slice = [].slice;

Stream = (function() {
  var fs, mime, path;

  fs = require('fs');

  path = require('path');

  mime = require('mime');

  function Stream(path) {
    this.path = path;
  }

  Stream.prototype.cachecheck = function(req, res, stats) {
    var etags, match, mtime, range, since;
    mtime = stats.mtime.toUTCString();
    since = (new Date(req.headers['if-modified-since'])).toUTCString();
    res.setHeader('Last-Modified', mtime);
    if (since >= mtime) {
      return true;
    }
    etags = "\"" + stats.dev + "-" + stats.ino + "-" + mtime + "\"";
    match = req.headers['if-none-match'];
    res.setHeader('ETag', etags);
    if (etags === match) {
      return true;
    }
    range = req.headers['If-Range'];
    if (mtime === (new Date(range)).toUTCString()) {
      return true;
    }
    if (etags === range) {
      return true;
    }
    return false;
  };

  Stream.prototype.rangeParser = function(req, res, stats) {
    var end, ini, size, _ref, _ref1;
    size = stats.size;
    if (((_ref = req.headers) != null ? _ref.range : void 0) != null) {
      res.statusCode = 206;
      _ref1 = req.headers.range.replace('bytes=', '').split('-').map(function(n) {
        return parseInt(n, 10);
      }), ini = _ref1[0], end = _ref1[1];
      if ((isNaN(end)) || (end === 0)) {
        end = size - 1;
      }
      res.setHeader('Content-Length', end + 1 - ini);
      res.setHeader('Content-Range', "bytes " + ini + "-" + end + "/" + size);
      res.setHeader('Accept-Range', 'bytes');
      res.setHeader('Transfer-Encoding', 'chunked');
      return [ini, end];
    } else {
      res.statusCode = 200;
      res.setHeader('Content-Length', size);
      return [0, size - 1];
    }
  };

  Stream.prototype["interface"] = function() {
    var callback, options, opts, req, res, src,
      _this = this;
    req = arguments[0], res = arguments[1], src = arguments[2], opts = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    options = {};
    callback = function() {};
    while (opts.shift()) {
      if (typeof opt === 'object') {
        options = opt;
      }
      if (typeof opt === 'function') {
        callback = opt;
      }
    }
    options.headers || (options.headers = {});
    src = path.join(this.path, src);
    return fs.stat(src, function(err, stats) {
      var end, key, start, stream, value, _base, _base1, _ref, _ref1;
      if (err) {
        callback(err, 0, 0);
        res.statusCode = 500;
        return next(err);
      }
      if (_this.cachecheck(req, res, stats)) {
        callback(null, 0, 1);
        res.statusCode = 304;
        return res.end();
      }
      (_base = options.headers)['Cache-Control'] || (_base['Cache-Control'] = 'public');
      (_base1 = options.headers)['Content-Type'] || (_base1['Content-Type'] = mime.lookup(src));
      _ref = options.headers;
      for (key in _ref) {
        value = _ref[key];
        res.setHeader(key, value);
      }
      _ref1 = _this.rangeParser(req, res, stats), start = _ref1[0], end = _ref1[1];
      if (start > end || stats.size < start) {
        res.statusCode = 416;
        start = 0;
        end = stats.size - 1;
        res.setHeader('Content-Length', end + 1 - start);
        res.setHeader('Content-Range', "" + start + "-" + end + "/" + stats.size);
      }
      stream = fs.createReadStream(src, {
        start: start,
        end: end
      });
      stream.on('close', function() {
        return callback(null, start, end);
      });
      stream.on('error', function(err) {
        console.error('>', err);
        return callback(err, start, end);
      });
      return stream.pipe(res);
    });
  };

  return Stream;

})();

module.exports = function(path) {
  if (path == null) {
    path = '';
  }
  return function(req, res, next) {
    var stream;
    stream = new Stream(path);
    res.stream = function() {
      var opts, src;
      src = arguments[0], opts = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return stream["interface"](req, res, src, opts);
    };
    return next();
  };
};
